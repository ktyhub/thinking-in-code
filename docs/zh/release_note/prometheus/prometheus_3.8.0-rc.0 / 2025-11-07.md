# prometheus 3.8.0-rc.0 / 2025-11-07
### 为什么要使用Prometheus

想象一下这样的深夜：警报嘶鸣，仪表盘上红光一片，整个技术团队如临大敌，但无人能说清问题的根源——是数据库连接池耗尽？是微服务链路中某个隐秘的慢查询？还是刚刚上线的代码存在资源泄漏？在系统日益复杂如星辰迷宫的今天，我们仿佛在黑暗中驾驶一架高速飞机，却没有可靠的仪表盘。传统的监控工具往往给我们一堆冰冷的数字和图表，却无法回答“为什么”和“接下来会怎样”。

这就是Prometheus登场时刻，它不仅仅是一个监控工具，更像是一位拥有预知能力的系统侦探。它强大的多维数据模型和灵活的查询语言（PromQL），让你能够像分析社会网络关系一样，去洞察指标背后复杂的关联与因果。选择Prometheus，意味着你选择从被动“救火”转向主动“洞察”，从面对“未知故障”的恐惧，转变为拥有“预测与预防”的底气。它帮你将系统的喃喃低语，翻译成清晰可执行的行动指令。

### Prometheus是什么

简单来说，Prometheus是一个开源的系统监控与警报工具包。它的核心工作是**收集**（从你的应用、服务、系统中抓取指标）、**存储**（将这些时间序列数据高效地存入其内置的时序数据库）、以及**分析**（通过强大的PromQL语言进行查询和聚合）。它诞生于云原生时代，以其简单的架构、可靠的数据模型和活跃的生态，已成为监控领域的基石，是云原生计算基金会（CNCF）的毕业项目。

### 入门示例

**真实场景：** 假设你运营一个电子商务网站，正面临“黑色星期五”的大流量挑战。你需要确保：
1.  **业务健康**：用户下单成功率、支付接口平均响应时间。
2.  **系统健康**：服务器CPU/内存使用率、应用容器的重启次数、数据库连接数。

**如何用Prometheus实现？**

1.  **暴露指标**：你的“订单服务”（假设用Go编写）可以集成Prometheus客户端库，在`/metrics`端点暴露如`http_request_duration_seconds`（HTTP请求耗时）等内置指标，并自定义一个`orders_placed_total`（订单总数）的业务计数器。
    ```go
    // 示例：使用Go客户端库增加一个订单计数器
    import (
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
    )
    var (
        ordersPlaced = prometheus.NewCounter(
            prometheus.CounterOpts{
                Name: “orders_placed_total",
                Help: “The total number of placed orders.",
            },
        )
    )
    func init() {
        prometheus.MustRegister(ordersPlaced)
    }
    // 在处理订单的函数中
    func placeOrder(w http.ResponseWriter, r *http.Request) {
        // ... 业务逻辑 ...
        ordersPlaced.Inc() // 指标增加
    }
    ```
2.  **配置抓取**：在Prometheus服务器的配置文件中，添加一个针对“订单服务”的抓取任务（scrape job），指定其服务发现地址（例如Kubernetes DNS名称或静态IP）。
3.  **查询与告警**：大促期间，你可以在Prometheus的查询界面（或配套的Grafana看板）中，使用PromQL实时分析：
    *   `rate(http_request_duration_seconds_sum[5m]) / rate(http_request_duration_seconds_count[5m])`：计算过去5分钟的平均请求延迟。
    *   `sum(rate(orders_placed_total[1h]))`：计算过去一小时的订单总量。
    *   你可以设置警报规则（Alerting Rule），例如：当“平均订单处理延迟高于500毫秒持续2分钟”时，自动触发告警通知团队。

### Prometheus 3.8.0-rc.0 / 2025-11-07版本更新了什么

本次版本是3.8.0的候选版本，主要聚焦于功能增强和稳定性提升。核心更新包括：原生直方图功能现已稳定并可通过配置启用；新增了统一的AWS服务发现机制以简化云上配置；在用户界面（UI）和PromQL编辑器中对新函数和重标记步骤提供了更好的支持；同时包含了一系列的性能优化和错误修复，提升了大规模部署下的效率与可靠性。

### 更新日志

*   **[变更] TSDB**：现在会拒绝包含 NaN（非数字）阈值的原生直方图自定义边界。
*   **[功能] Dockerfile**：在 Dockerfile 中添加了 OpenContainers 规范标签。
*   **[功能] 服务发现**：为 EC2、Lightsail 和 ECS 服务新增了统一的 AWS 服务发现机制。
*   **[功能] 原生直方图**：原生直方图现已是一项稳定但可选的功能，可通过 `scrape_native_histogram` 配置设置启用。
*   **[功能] 用户界面**：在 PromQL 编辑器中支持 `anchored` 和 `smoothed` 关键词。
*   **[功能] 用户界面**：为每个发现的目标显示详细的重标记步骤。
*   **[功能] 告警**：在模板函数中添加了 `urlQueryEscape`。
*   **[功能] Promtool**：通过 `--protobuf_message` 标志，为 `promtool push metrics` 命令添加了 Remote-Write 2.0 支持。
*   **[增强] 文档**：澄清了关于处理负值原生直方图的文档。
*   **[增强] Mixin**：为远程写入仪表板添加了静态 UID。
*   **[增强] PromQL**：在 `Add` 和 `Sub` 操作中协调不匹配的原生直方图自定义边界。
*   **[增强] 告警**：为尚未评估的告警规则添加“未知”状态。
*   **[增强] 抓取**：允许同时使用经典直方图到原生直方图自定义边界的转换和零时间戳摄取。
*   **[增强] 用户界面**：在解释说明中添加 `smoothed`/`anchored` 信息。
*   **[增强] OTLP**：对同一时间序列同一时间戳的任何 `target_info` 样本进行去重。
*   **[增强] 文档**：在 `sigv4` 配置部分记录 `use_fips_sts_endpoint` 选项。
*   **[增强] 文档**：新增关于 Prometheus Agent 的文档。
*   **[性能] PromQL**：加速可变参数函数的解析。
*   **[性能] 用户界面**：通过不渲染已折叠的内容来加速告警/规则等页面的加载。
*   **[性能] 用户界面**：在 PromQL 编辑器中获取标签名称和值时进行性能改进。
*   **[性能] 用户界面**：通过虚拟滚动技术加速在存在大量触发中告警时的 `/alerts` 页面加载速度。
*   **[修复] PromQL**：修复了 `info` 函数在序列频繁变动时的切片索引错误。
*   **[修复] API**：减少 `/api/v1/targets` 接口上的锁争用。
*   **[修复] PromQL**：在聚合操作中统一处理仪表盘直方图与计数器直方图。
*   **[修复] TSDB**：允许将 `-Inf` 作为第一个自定义值用于原生直方图自定义边界。
*   **[修复] 用户界面**：修复了从 API 重复加载数据的问题，加速了某些页面的渲染。
*   **[修复] 旧版用户界面**：修复了 `createExpressionLink`