# prometheus 3.8.0 / 2025-11-28
### 为什么要使用 Prometheus

想象一下，你正驾驶着一架高速喷气式飞机穿越雷暴云层，但驾驶舱里没有仪表盘。发动机温度？未知。燃油存量？猜猜看。机舱外的风速和闪电距离？全凭直觉。这就是现代数字系统在没有恰当监控时所面临的黑暗飞行——每一次上线都如同一次盲目的冒险，每一个故障都可能是一场灾难。

Prometheus 的出现，如同为这架飞机装上了最先进的平视显示器。它并非另一个枯燥的数据收集器，而是一位沉默的预言家，在浩瀚的比特洪流中为你点亮信号。当你被“为什么服务突然变慢？”、“是数据库还是缓存出了问题？”、“容量预警何时触发？”这类问题折磨时，传统的监控工具往往给你一堆杂乱的历史图表，而 Prometheus 直接递给你一个带有时间刻度的“为什么”。

矛盾恰恰在于此：在追求无限扩展和敏捷交付的云原生时代，我们对系统内部状态的了解却可能倒退到了原始时代。你部署的微服务越多，失控的迷雾就越浓。Prometheus 以其独特的拉取模型、强大的多维数据模型和直白的查询语言（PromQL），将控制权交还给你。它不满足于告诉你“系统死了”，它旨在回答“系统为何会死，以及如何在下次死亡前拯救它”。选择 Prometheus，就是选择在复杂性中维持清醒，在混沌中建立秩序。它让你从被动的故障响应者，转变为主动的系统洞察者。

### Prometheus 是什么

Prometheus 是一个开源的系统监控和警报工具包。它通过主动从配置好的目标（如应用程序、服务器）上“拉取”指标数据，存入自身高效的时间序列数据库中。你可以使用灵活的 PromQL 语言查询这些数据，生成图表、进行实时分析，并基于预定义的规则触发警报。它专为可靠性设计，在基础设施出现问题时也能独立运行，是云原生计算基金会（CNCF）毕业的项目，已成为监控容器化和动态服务的核心工具。

### 入门示例

**真实场景：** 假设你运营一个在线电商网站“ShopFast”。黑色星期五期间，流量激增，你需要确保核心的“下单”服务稳定运行。

**开发示例：**
1.  **为应用添加指标暴露：** 在你的“下单”服务（假设用Go编写）中，集成 Prometheus 客户端库。
    ```go
    import "github.com/prometheus/client_golang/prometheus"
    
    var (
        ordersProcessed = prometheus.NewCounter(
            prometheus.CounterOpts{
                Name: “shopfast_orders_processed_total",
                Help: “处理的总订单数",
            },
        )
        orderDuration = prometheus.NewHistogram(
            prometheus.HistogramOpts{
                Name: “shopfast_order_duration_seconds",
                Help: “处理订单的耗时分布",
                Buckets: prometheus.DefBuckets, // 默认桶
            },
        )
    )
    
    func init() {
        prometheus.MustRegister(ordersProcessed, orderDuration)
    }
    
    func handleOrder(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        defer func() { orderDuration.Observe(time.Since(start).Seconds()) }()
        
        // 处理订单业务逻辑...
        ordersProcessed.Inc()
        
        w.WriteHeader(http.StatusOK)
    }
    ```
2.  **配置 Prometheus 拉取：** 创建一个 `prometheus.yml` 配置文件。
    ```yaml
    global:
      scrape_interval: 15s # 每15秒拉取一次
    
    scrape_configs:
      - job_name: ‘shopfast-order-service’
        static_configs:
          - targets: [‘order-service:8080’] # 你的服务地址和端口
    ```
3.  **启动与查询：**
    *   启动 Prometheus 服务，指向该配置文件。
    *   访问 Prometheus 的 Web UI（默认9090端口）。
    *   在查询框中输入 `rate(shopfast_orders_processed_total[5m])`，即可看到过去5分钟内订单处理的速率，快速判断流量趋势。设置警报规则，当订单处理延迟的99分位数（`histogram_quantile(0.99, rate(shopfast_order_duration_seconds_bucket[5m]))`）超过1秒时，触发告警，以便在用户体验恶化前介入。

### Prometheus 3.8.0 / 2025-11-28版本更新了什么

Prometheus 3.8.0 是一个重要版本，标志着原生直方图功能进入稳定阶段。主要更新包括：将原生直方图作为需显式开启的稳定功能引入；远程写入规范升级至2.0-rc.4；新增了统一的AWS服务发现以简化EC2、Lightsail和ECS的监控配置；在用户界面增强了PromQL编辑器并支持显示详细的重标记步骤；此外，还包含了多项性能优化（如加快变参函数解析和UI渲染）及错误修复，提升了整体稳定性和用户体验。

### 更新日志

#### 给原生直方图用户的提示

这是首个将原生直方图作为稳定功能发布的版本。但是，必须通过本版本新引入的 `scrape_native_histogram` 配置设置来显式激活对原生直方图的抓取。为了便于过渡，在本版本中，`--enable-feature=native-histograms` 功能标志并非完全无操作，它会将 `scrape_native_histogram` 的默认值改为 `true`。在下一个版本 (v3.9) 中，该功能标志**将**完全无操作，并且 `scrape_native_histogram` 的默认值将始终为 `false`。

如果您迄今为止一直在使用该功能标志，推荐的操作步骤如下：

1.  升级到 v3.8 并保留功能标志。一切应如常工作。
2.  在您方便的时候，在所有相关的抓取配置中将 `scrape_native_histogram` 设置为 `true`。（`scrape_native_histogram` 既有全局版本，也有按抓取配置的版本，以便在需要时进行细粒度控制。建议在不想抓取原生直方图的地方也显式地将 `scrape_native_histogram` 设置为 `false`。这样，您就不再依赖于该设置的默认值。）
3.  移除功能标志，并确保一切仍按预期工作。
4.  现在您已准备好升级到下一个版本 (v3.9)。

#### 变更日志

*   **[变更]** 远程写入 2 (接收)：更新至 [2.0-rc.4 规范](https://github.com/prometheus/docs/blob/60c24e450010df38cfcb4f65df874f6f9b26dbcb/docs/specs/prw/remote_write_spec_2_0.md)。“创建时间戳” 现改称为 “开始时间戳”。
*   **[变更]** TSDB：现在会拒绝包含 NaN 阈值的原生直方图自定义边界。
*   **[功能]** OAuth2：支持 jwt-bearer 授权类型。
*   **[功能]** Dockerfile：在 Dockerfile 中添加 OpenContainers 规范标签。
*   **[功能]** 服务发现：为 ec2、lightsail 和 ecs 服务新增统一的 AWS 服务发现。
*   **[功能]** 原生直方图现已成为一项稳定但可选的功能，使用 `scrape_native_histogram` 配置设置。
*   **[功能]** 用户界面：在 PromQL 编辑器中支持 `anchored` 和 `smoothed` 关键字。
*   **[功能]** 用户界面：为每个发现的目标显示详细的重标记步骤。
*   **[功能]** 告警：在模板函数中添加 `urlQueryEscape`。
*   **[功能]** Promtool：通过 `--protobuf_message